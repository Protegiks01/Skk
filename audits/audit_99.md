## Title
Asymmetric Investment Vault Configuration Enables Yield Theft Through Shared Share Price Mechanism

## Summary
The `registerVault()` function silently skips investment vault configuration when the investment vault lookup returns `address(0)`, creating an asymmetric state where some vaults can generate yield through investments while others cannot. Since all vaults share a single `ShareToken` with a unified share price calculation that includes invested assets globally, users depositing into non-investing vaults receive proportional yield benefits from investing vaults without contributing any investment returns, effectively stealing yield from legitimate investors.

## Impact
**Severity**: High

## Finding Description
**Location:** `src/ShareTokenUpgradeable.sol` - `_configureVaultInvestmentSettings()` function and `getCirculatingSupplyAndAssets()` function

**Intended Logic:** When registering a new vault, if `investmentShareToken` is already configured, the system should ensure all vaults have equal investment capabilities to maintain fair yield distribution across all depositors who share the same `ShareToken`.

**Actual Logic:** The `_configureVaultInvestmentSettings()` function performs a lookup at line 542 and silently skips configuration if no investment vault exists for that asset: [1](#0-0) 

This creates an asymmetric state where:
- Vaults WITH investment vault configuration can call `investAssets()` to generate yield
- Vaults WITHOUT investment vault configuration will revert with `NoInvestmentVault()` error when attempting to invest [2](#0-1) 

The critical issue is that ALL vaults share the same global share price calculation that includes invested assets from any vault: [3](#0-2) 

The `_calculateInvestmentAssets()` function returns the ShareToken's total balance in the investment ShareToken without distinguishing which vault generated those returns: [4](#0-3) 

**Exploitation Path:**
1. Owner registers Vault A (USDC) which has a corresponding investment vault configured in the investment ShareToken
2. Owner registers Vault B (DAI) which does NOT have a corresponding investment vault configured
3. Alice deposits 1,000,000 USDC into Vault A → receives 1,000,000 shares at initial 1:1 ratio
4. Bob deposits 1,000,000 DAI into Vault B → receives 1,000,000 shares at same 1:1 ratio
5. Investment Manager calls `investAssets()` on Vault A, investing all USDC into the investment vault
6. Investment vault generates 10% yield on USDC investments (100,000 USDC profit)
7. ShareToken's balance in investment ShareToken increases by 100,000 shares (18-decimal normalized)
8. `getCirculatingSupplyAndAssets()` now returns: totalNormalizedAssets = 1,000,000 (Vault A) + 1,000,000 (Vault B) + 100,000 (invested) = 2,100,000
9. Share price = 2,100,000 / 2,000,000 = 1.05 for BOTH Alice and Bob
10. Bob redeems his shares: 1,000,000 shares * 1.05 = 1,050,000 DAI worth of value
11. Bob extracted 50,000 DAI worth of value despite Vault B generating zero investment returns

**Security Property Broken:** This violates the fundamental economic fairness principle and the "No Fund Theft" invariant (Invariant #12), as users in non-investing vaults are extracting value generated exclusively by users in investing vaults.

## Impact Explanation
- **Affected Assets**: All assets in vaults configured without investment capability, and all assets in vaults WITH investment capability (yield dilution)
- **Damage Severity**: The yield generated by investing vaults is redistributed to all vault depositors proportionally based on share holdings, not based on which vaults actually generated returns. In a scenario where 50% of depositors are in non-investing vaults, they would steal ~50% of all investment yields.
- **User Impact**: Every user who deposits into an investing vault loses a portion of their rightful yield to users in non-investing vaults. This is automatic and unavoidable once the asymmetric configuration exists.

## Likelihood Explanation
- **Attacker Profile**: Any user can exploit this by simply depositing into the non-investing vault. No special permissions required.
- **Preconditions**: Owner must have registered at least one vault with investment capability and one vault without. This is a likely scenario given the silent failure mode in `_configureVaultInvestmentSettings()`.
- **Execution Complexity**: Single deposit transaction. The yield theft occurs automatically through normal protocol operations.
- **Frequency**: Continuous - every investment cycle redistributes yield unfairly. Exploitable by any number of users simultaneously.

## Recommendation

**Fix 1 (Recommended): Enforce Investment Vault Configuration During Registration** [1](#0-0) 

```solidity
// In src/ShareTokenUpgradeable.sol, function _configureVaultInvestmentSettings, lines 540-551:

// CURRENT (vulnerable):
function _configureVaultInvestmentSettings(address asset, address vaultAddress, address investmentShareToken) internal {
    address investmentVaultAddress = IERC7575ShareExtended(investmentShareToken).vault(asset);
    
    if (investmentVaultAddress != address(0)) {
        ERC7575VaultUpgradeable(vaultAddress).setInvestmentVault(IERC7575(investmentVaultAddress));
        IERC20(investmentShareToken).approve(vaultAddress, type(uint256).max);
    }
}

// FIXED:
function _configureVaultInvestmentSettings(address asset, address vaultAddress, address investmentShareToken) internal {
    address investmentVaultAddress = IERC7575ShareExtended(investmentShareToken).vault(asset);
    
    // CRITICAL FIX: Revert if investment vault is not configured for this asset
    // This prevents asymmetric investment capabilities across vaults sharing the same ShareToken
    if (investmentVaultAddress == address(0)) {
        revert NoInvestmentVaultForAsset(asset);
    }
    
    ERC7575VaultUpgradeable(vaultAddress).setInvestmentVault(IERC7575(investmentVaultAddress));
    IERC20(investmentShareToken).approve(vaultAddress, type(uint256).max);
}

// Add to IERC7575Errors.sol:
error NoInvestmentVaultForAsset(address asset);
```

**Fix 2 (Alternative): Per-Vault Investment Asset Tracking**

Modify `getCirculatingSupplyAndAssets()` to track invested assets per vault rather than globally, ensuring each vault's share price reflects only its own investment returns. This requires significant architectural changes to maintain per-vault investment balances.

## Proof of Concept

```solidity
// File: test/Exploit_AsymmetricInvestmentYieldTheft.t.sol
// Run with: forge test --match-test test_AsymmetricInvestmentYieldTheft -vvv

pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

import {ERC20Faucet6} from "../src/ERC20Faucet6.sol";
import {ERC7575VaultUpgradeable} from "../src/ERC7575VaultUpgradeable.sol";
import {ShareTokenUpgradeable} from "../src/ShareTokenUpgradeable.sol";
import {WERC7575ShareToken} from "../src/WERC7575ShareToken.sol";
import {WERC7575Vault} from "../src/WERC7575Vault.sol";

contract Exploit_AsymmetricInvestmentYieldTheft is Test {
    ERC20Faucet6 public usdc;
    ERC20Faucet6 public dai;
    
    WERC7575ShareToken public investmentShareToken;
    WERC7575Vault public investmentUsdcVault;
    // Note: NO investment DAI vault created!
    
    ShareTokenUpgradeable public shareToken;
    ERC7575VaultUpgradeable public usdcVault;
    ERC7575VaultUpgradeable public daiVault;
    
    address public owner = address(0x1);
    address public investmentManager = address(0x2);
    address public validator = address(0x3);
    address public alice = address(0x4); // USDC depositor
    address public bob = address(0x5);   // DAI depositor (attacker)
    
    uint256 constant INITIAL_SUPPLY = 1_000_000_000 * 1e6;
    
    function setUp() public {
        vm.startPrank(owner);
        
        // Deploy tokens
        usdc = new ERC20Faucet6("USD Coin", "USDC", INITIAL_SUPPLY);
        dai = new ERC20Faucet6("Dai", "DAI", INITIAL_SUPPLY);
        
        // Deploy investment system with ONLY USDC vault (asymmetric!)
        investmentShareToken = new WERC7575ShareToken("Investment USD", "iUSD");
        investmentUsdcVault = new WERC7575Vault(address(usdc), investmentShareToken);
        investmentShareToken.registerVault(address(usdc), address(investmentUsdcVault));
        // CRITICAL: No DAI investment vault registered!
        
        investmentShareToken.setValidator(validator);
        investmentShareToken.setKycAdmin(validator);
        
        // Deploy settlement ShareToken
        ShareTokenUpgradeable shareTokenImpl = new ShareTokenUpgradeable();
        bytes memory initData = abi.encodeWithSelector(
            ShareTokenUpgradeable.initialize.selector,
            "Multi-Asset Shares", "MAS", owner
        );
        ERC1967Proxy shareTokenProxy = new ERC1967Proxy(address(shareTokenImpl), initData);
        shareToken = ShareTokenUpgradeable(address(shareTokenProxy));
        
        // Deploy both vaults
        usdcVault = _deployVault(address(usdc));
        daiVault = _deployVault(address(dai));
        
        // Register both vaults
        shareToken.registerVault(address(usdc), address(usdcVault));
        shareToken.registerVault(address(dai), address(daiVault));
        
        // Configure investment (this creates asymmetric state!)
        shareToken.setInvestmentManager(investmentManager);
        shareToken.setInvestmentShareToken(address(investmentShareToken));
        
        vm.stopPrank();
        
        // Setup KYC
        vm.startPrank(validator);
        investmentShareToken.setKycVerified(address(shareToken), true);
        investmentShareToken.setKycVerified(alice, true);
        investmentShareToken.setKycVerified(bob, true);
        vm.stopPrank();
        
        // Fund users
        usdc.transfer(alice, 1_000_000 * 1e6);
        dai.transfer(bob, 1_000_000 * 1e6);
    }
    
    function test_AsymmetricInvestmentYieldTheft() public {
        // SETUP: Alice deposits USDC, Bob deposits DAI
        vm.startPrank(alice);
        usdc.approve(address(usdcVault), type(uint256).max);
        usdcVault.requestDeposit(1_000_000 * 1e6, alice, alice);
        vm.stopPrank();
        
        vm.startPrank(bob);
        dai.approve(address(daiVault), type(uint256).max);
        daiVault.requestDeposit(1_000_000 * 1e6, bob, bob);
        vm.stopPrank();
        
        // Fulfill deposits
        vm.startPrank(investmentManager);
        usdcVault.fulfillDeposit(alice, 1_000_000 * 1e6);
        daiVault.fulfillDeposit(bob, 1_000_000 * 1e6);
        vm.stopPrank();
        
        // Claim shares
        vm.prank(alice);
        usdcVault.deposit(1_000_000 * 1e6, alice, alice);
        
        vm.prank(bob);
        daiVault.deposit(1_000_000 * 1e6, bob, bob);
        
        // Record initial share price
        uint256 aliceShares = shareToken.balanceOf(alice);
        uint256 bobShares = shareToken.balanceOf(bob);
        
        console.log("Initial state:");
        console.log("  Alice shares:", aliceShares);
        console.log("  Bob shares:", bobShares);
        
        // EXPLOIT: Investment manager invests USDC assets
        vm.startPrank(investmentManager);
        uint256 investAmount = 1_000_000 * 1e6;
        usdcVault.investAssets(investAmount);
        vm.stopPrank();
        
        // Simulate 10% yield in investment vault by minting to ShareToken
        vm.startPrank(address(investmentUsdcVault));
        uint256 yieldAmount = 100_000 * 1e18; // 10% yield (18 decimals)
        investmentShareToken.mint(address(shareToken), yieldAmount);
        vm.stopPrank();
        
        // VERIFY: Both Alice and Bob benefit from yield despite only USDC generating it
        (uint256 circulatingSupply, uint256 totalAssets) = shareToken.getCirculatingSupplyAndAssets();
        uint256 sharePrice = (totalAssets * 1e18) / circulatingSupply;
        
        console.log("\nAfter USDC investment with 10% yield:");
        console.log("  Total normalized assets:", totalAssets);
        console.log("  Circulating supply:", circulatingSupply);
        console.log("  Share price (scaled 1e18):", sharePrice);
        
        // Calculate value extraction
        uint256 aliceValue = (aliceShares * totalAssets) / circulatingSupply;
        uint256 bobValue = (bobShares * totalAssets) / circulatingSupply;
        
        console.log("\nValue distribution:");
        console.log("  Alice value:", aliceValue);
        console.log("  Bob value:", bobValue);
        
        // CRITICAL ASSERTION: Bob receives yield despite DAI vault having no investment capability
        uint256 expectedAliceValue = 1_000_000 * 1e18; // Initial deposit
        uint256 expectedBobValue = 1_000_000 * 1e18; // Initial deposit
        
        assertGt(bobValue, expectedBobValue, "Bob should have received yield");
        assertGt(aliceValue, expectedAliceValue, "Alice should have received yield");
        
        // The yield is split 50/50 despite only USDC generating returns
        uint256 totalYield = totalAssets - (expectedAliceValue + expectedBobValue);
        uint256 bobYieldTheft = bobValue - expectedBobValue;
        uint256 aliceActualYield = aliceValue - expectedAliceValue;
        
        console.log("\nYield theft analysis:");
        console.log("  Total yield generated:", totalYield);
        console.log("  Bob's stolen yield:", bobYieldTheft);
        console.log("  Alice's actual yield:", aliceActualYield);
        console.log("  Theft percentage:", (bobYieldTheft * 100) / totalYield);
        
        assertApproxEqRel(bobYieldTheft, totalYield / 2, 0.01e18, "Bob stole ~50% of yield");
    }
    
    function _deployVault(address asset) internal returns (ERC7575VaultUpgradeable) {
        ERC7575VaultUpgradeable vaultImpl = new ERC7575VaultUpgradeable();
        bytes memory initData = abi.encodeWithSelector(
            ERC7575VaultUpgradeable.initialize.selector,
            IERC20Metadata(asset),
            address(shareToken),
            owner
        );
        ERC1967Proxy vaultProxy = new ERC1967Proxy(address(vaultImpl), initData);
        return ERC7575VaultUpgradeable(address(vaultProxy));
    }
}
```

## Notes

This vulnerability stems from the architectural decision to share a single `ShareToken` and unified share price across multiple asset vaults while allowing asymmetric investment capabilities. The silent failure mode in `_configureVaultInvestmentSettings()` at line 545 makes this especially dangerous, as vault registration succeeds without any indication that investment capability is missing. [5](#0-4) 

The automatic configuration in `registerVault()` calls `_configureVaultInvestmentSettings()` which performs the problematic lookup and silent skip. The recommendation to revert on `address(0)` investment vault lookup would force protocol owners to ensure all registered vaults have equal investment capabilities before allowing registration, maintaining economic fairness across all depositors.

### Citations

**File:** src/ShareTokenUpgradeable.sol (L220-232)
```text
        // If investment ShareToken is already configured, set up investment for the new vault
        // Only configure if the vault address is a deployed contract
        address investmentShareToken = $.investmentShareToken;
        if (investmentShareToken != address(0)) {
            _configureVaultInvestmentSettings(asset, vaultAddress, investmentShareToken);
        }

        // If investment manager is already configured, set it for the new vault
        // Only configure if the vault address is a deployed contract
        address investmentManager = $.investmentManager;
        if (investmentManager != address(0)) {
            ERC7575VaultUpgradeable(vaultAddress).setInvestmentManager(investmentManager);
        }
```

**File:** src/ShareTokenUpgradeable.sol (L369-390)
```text
    function getCirculatingSupplyAndAssets() external view returns (uint256 circulatingSupply, uint256 totalNormalizedAssets) {
        ShareTokenStorage storage $ = _getShareTokenStorage();
        uint256 totalClaimableShares = 0;
        uint256 length = $.assetToVault.length();

        for (uint256 i = 0; i < length; i++) {
            (, address vaultAddress) = $.assetToVault.at(i);

            // Get both claimable shares and normalized assets in a single call for gas efficiency
            (uint256 vaultClaimableShares, uint256 vaultNormalizedAssets) = IERC7575Vault(vaultAddress).getClaimableSharesAndNormalizedAssets();
            totalClaimableShares += vaultClaimableShares;
            totalNormalizedAssets += vaultNormalizedAssets;
        }

        // Add invested assets from the investment ShareToken (if configured)
        totalNormalizedAssets += _calculateInvestmentAssets();

        // Get total supply
        uint256 supply = totalSupply();
        // Calculate circulating supply: total supply minus vault-held shares for redemption claims
        circulatingSupply = totalClaimableShares > supply ? 0 : supply - totalClaimableShares;
    }
```

**File:** src/ShareTokenUpgradeable.sol (L540-551)
```text
    function _configureVaultInvestmentSettings(address asset, address vaultAddress, address investmentShareToken) internal {
        // Find the corresponding investment vault for this asset
        address investmentVaultAddress = IERC7575ShareExtended(investmentShareToken).vault(asset);

        // Configure investment vault if there's a matching one for this asset
        if (investmentVaultAddress != address(0)) {
            ERC7575VaultUpgradeable(vaultAddress).setInvestmentVault(IERC7575(investmentVaultAddress));

            // Grant unlimited allowance to the vault on the investment ShareToken
            IERC20(investmentShareToken).approve(vaultAddress, type(uint256).max);
        }
    }
```

**File:** src/ShareTokenUpgradeable.sol (L603-620)
```text
    function _calculateInvestmentAssets() internal view returns (uint256 totalInvestmentAssets) {
        ShareTokenStorage storage $ = _getShareTokenStorage();
        address investmentShareToken = $.investmentShareToken;

        if (investmentShareToken == address(0)) {
            return 0;
        }

        // Get our balance of investment ShareToken (already normalized to 18 decimals)
        totalInvestmentAssets = IERC20(investmentShareToken).balanceOf(address(this));

        // Add rBalanceOf (reserved balance) if the investment share token supports it
        try IWERC7575ShareToken(investmentShareToken).rBalanceOf(address(this)) returns (uint256 rShares) {
            totalInvestmentAssets += rShares;
        } catch {
            // If rBalanceOf is not supported, continue with regular balance only
        }
    }
```

**File:** src/ERC7575VaultUpgradeable.sol (L1448-1465)
```text
    function investAssets(uint256 amount) external nonReentrant returns (uint256 shares) {
        VaultStorage storage $ = _getVaultStorage();
        if (msg.sender != $.investmentManager) revert OnlyInvestmentManager();
        if ($.investmentVault == address(0)) revert NoInvestmentVault();
        if (amount == 0) revert ZeroAmount();

        uint256 availableBalance = totalAssets();
        if (amount > availableBalance) {
            revert ERC20InsufficientBalance(address(this), availableBalance, amount);
        }

        // Approve and deposit into investment vault with ShareToken as receiver
        IERC20Metadata($.asset).safeIncreaseAllowance($.investmentVault, amount);
        shares = IERC7575($.investmentVault).deposit(amount, $.shareToken);

        emit AssetsInvested(amount, shares, $.investmentVault);
        return shares;
    }
```
